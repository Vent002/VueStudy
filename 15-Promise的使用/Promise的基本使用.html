<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  //1. 使用setTimeout
  // setTimeout(() => {
  //   console.log('Hello World');
  // },1000)

  //参数 -> 函数(resolve,reject)
  //resolve,reject 本身又是函数
  // 链式编程
  // new Promise((resolve,reject) => {
  //
  //   // 第一次网络请求的代码
  //   setTimeout(() => {
  //     resolve()
  //   },1000)
  // }).then(() => {
  //   // 第一次拿到结果的处理代码
  //   console.log('Hello world');
  //   console.log('Hello world');
  //   console.log('Hello world');
  //   console.log('Hello world');
  //   console.log('Hello world');
  //   return new Promise((resolve,reject) => {
  //     // 第二次网络请求的代码
  //     setTimeout(() => {
  //       resolve()
  //     },1000)
  //   }).then(() => {
  //     // 第二次结果
  //     console.log('Hello vue');
  //     console.log('Hello vue');
  //     console.log('Hello vue');
  //     console.log('Hello vue');
  //     console.log('Hello vue');
  //     console.log('Hello vue');
  //   })
  // })

  //什么情况下会用到Promise
  //一般情况下有异步操作时，使用Promise 对异步操作进行封装
  // new -> 构造函数 （1. 保存了一些状态信息  2. 执行传入的函数）
  // 在执行传入的回调函数时，会传入两个参数，resolve reject  本身又是函数
new Promise((resolve,reject) => {
  //成功的时候调用resolve
  setTimeout(() => {
    //resolve('Hello world');

    //失败的时候调用reject
    reject('error message');
  },1000)
}).then((data) => { //一个参数的时候 小括号可以不写
  console.log(data);
  console.log(data);
  console.log(data);
  console.log(data);
}).catch((err) => {
  console.log(err);
})
</script>
</body>
</html>